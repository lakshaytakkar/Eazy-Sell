<mcp_external_output>

### Content Block 1 (Text)
{"searchDocs":{"nodes":[{"title":"Password-based Auth","href":"https://supabase.com/docs/guides/auth/passwords","content":"# Password-based Auth\n\nAllow users to sign in with a password connected to their email or phone number.\n\nUsers often expect to sign in to your site with a password. Supabase Auth helps you implement password-based auth safely, using secure configuration options and best practices for storing and verifying passwords.\n\nUsers can associate a password with their identity using their [email address](#with-email) or a [phone number](#with-phone).\n\n\n## With email\n\n\n### Enabling email and password-based authentication\n\nEmail authentication is enabled by default.\n\nYou can configure whether users need to verify their email to sign in. On hosted Supabase projects, this is true by default. On self-hosted projects or in local development, this is false by default.\n\nChange this setting on the [Auth Providers page](/dashboard/project/_/auth/providers) for hosted projects, or in the [configuration file](/docs/guides/cli/config#auth.email.enable_confirmations) for self-hosted projects.\n\n\n### Signing up with an email and password\n\nThere are two possible flows for email signup: [implicit flow](/docs/guides/auth/sessions#implicit-flow) and [PKCE flow](/docs/guides/auth/sessions#pkce-flow). If you're using SSR, you're using the PKCE flow. If you're using client-only code, the default flow depends upon the client library. The implicit flow is the default in JavaScript and Dart, and the PKCE flow is the default in Swift.\n\nThe instructions in this section assume that email confirmations are enabled.\n\n<Tabs\n  scrollable\n  stickyTabList={{\n    style: {\n      top: 'var(--header-height)',\n      backgroundColor: 'hsl(var(--background-default) / var(--tw-bg-opacity))',\n      maskImage: 'none',\n      borderBottom: '1px solid hsl(var(--border-default) / 1)',\n    }\n  }}\n  size=\"large\"\n  type=\"underlined\"\n  queryGroup=\"flow\"\n>\n  <TabPanel id=\"implicit\" label=\"Implicit flow\">\n    The implicit flow only works for client-only apps. Your site directly receives the access token after the user confirms their email.\n\n    <Tabs scrollable size=\"small\" type=\"underlined\" queryGroup=\"language\">\n      <TabPanel id=\"js\" label=\"JavaScript\">\n        To sign up the user, call [signUp()](/docs/reference/javascript/auth-signup) with their email address and password.\n\n        You can optionally specify a URL to redirect to after the user clicks the confirmation link. This URL must be configured as a [Redirect URL](/docs/guides/auth/redirect-urls), which you can do in the [dashboard](/dashboard/project/_/auth/url-configuration) for hosted projects, or in the [configuration file](/docs/guides/cli/config#auth.additional_redirect_urls) for self-hosted projects.\n\n        If you don't specify a redirect URL, the user is automatically redirected to your site URL. This defaults to `localhost:3000`, but you can also configure this.\n\n        ```js\n        import { createClient } from '@supabase/supabase-js'\n        const supabase = createClient('https://your-project.supabase.co', 'sb_publishable_... or anon key')\n\n        // ---cut---\n        async function signUpNewUser() {\n          const { data, error } = await supabase.auth.signUp({\n            email: 'valid.email@supabase.io',\n            password: 'example-password',\n            options: {\n              emailRedirectTo: 'https://example.com/welcome',\n            },\n          })\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"dart\" label=\"Dart\">\n        To sign up the user, call [signUp()](/docs/reference/dart/auth-signup) with their email address and password:\n\n        ```dart\n        Future<void> signUpNewUser() async {\n          final AuthResponse res = await supabase.auth.signUp(\n            email: 'valid.email@supabase.io',\n            password: 'example-password'\n          );\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"swift\" label=\"Swift\">\n        To sign up the user, call [signUp()](/docs/reference/swift/auth-signup) with their email address and password.\n\n        You can optionally specify a URL to redirect to after the user clicks the confirmation link. This URL must be configured as a [Redirect URL](/docs/guides/auth/redirect-urls), which you can do in the [dashboard](/dashboard/project/_/auth/url-configuration) for hosted projects, or in the [configuration file](/docs/guides/cli/config#auth.additional_redirect_urls) for self-hosted projects.\n\n        If you don't specify a redirect URL, the user is automatically redirected to your site URL. This defaults to `localhost:3000`, but you can also configure this.\n\n        ```swift\n        let response = try await supabase.auth.signUp(\n          email: \"valid.email@supabase.io\",\n          password: \"example-password\",\n          redirectTo: URL(string: \"https://example.com/welcome\")\n        )\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"kotlin\" label=\"Kotlin\">\n        To sign up the user, call [signUpWith(Email)](/docs/reference/kotlin/auth-signup) with their email address and password:\n\n        ```kotlin\n        suspend fun signUpNewUser() {\n        \tsupabase.auth.signUpWith(Email) {\n        \t\temail = \"valid.email@supabase.io\"\n        \t\tpassword = \"example-password\"\n        \t}\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"python\" label=\"Python\">\n        To sign up the user, call [signUp()](/docs/reference/python/auth-signup) with their email address and password.\n\n        You can optionally specify a URL to redirect to after the user clicks the confirmation link. This URL must be configured as a [Redirect URL](/docs/guides/auth/redirect-urls), which you can do in the [dashboard](/dashboard/project/_/auth/url-configuration) for hosted projects, or in the [configuration file](/docs/guides/cli/config#auth.additional_redirect_urls) for self-hosted projects.\n\n        If you don't specify a redirect URL, the user is automatically redirected to your site URL. This defaults to `localhost:3000`, but you can also configure this.\n\n        ```python\n        data = await supabase.auth.sign_up({\n          'email': 'valid.email@supabase.io',\n          'password': 'example-password',\n          'options': {\n            'email_redirect_to': 'https://example.com/welcome',\n          },\n        })\n        ```\n      </TabPanel>\n    </Tabs>\n  </TabPanel>\n\n  <TabPanel id=\"pkce\" label=\"PKCE flow\">\n    The PKCE flow allows for server-side authentication. Unlike the implicit flow, which directly provides your app with the access token after the user clicks the confirmation link, the PKCE flow requires an intermediate token exchange step before you can get the access token.\n\n    ##### Step 1: Update signup confirmation email\n\n    Update your signup email template to send the token hash. For detailed instructions on how to configure your email templates, including the use of variables like `{{ .SiteURL }}`, `{{ .TokenHash }}`, and `{{ .RedirectTo }}`, refer to our [Email Templates](/docs/guides/auth/auth-email-templates) guide.\n\n    Your signup email template should contain the following HTML:\n\n    ```html\n    <h2>Confirm your signup</h2>\n\n    <p>Follow this link to confirm your user:</p>\n    <p>\n      <a\n        href=\"{{ .SiteURL }}/auth/confirm?token_hash={{ .TokenHash }}&type=email&next={{ .RedirectTo }}\"\n        >Confirm your email</a\n      >\n    </p>\n    ```\n\n    ##### Step 2: Create token exchange endpoint\n\n    Create an API endpoint at `<YOUR_SITE_URL>/auth/confirm` to handle the token exchange.\n\n    <Admonition type=\"tip\">\n      Make sure you're using the right `supabase` client in the following code.\n\n      If you're not using Server-Side Rendering or cookie-based Auth, you can directly use the `createClient` from `@supabase/supabase-js`. If you're using Server-Side Rendering, see the [Server-Side Auth guide](/docs/guides/auth/server-side/creating-a-client) for instructions on creating your Supabase client.\n    </Admonition>\n\n    <Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"nextjs\" queryGroup=\"framework\">\n      <TabPanel id=\"nextjs\" label=\"Next.js\">\n        Create a new file at `app/auth/confirm/route.ts` and populate with the following:\n\n        ```ts app/auth/confirm/route.ts\n        import { type EmailOtpType } from '@supabase/supabase-js'\n        import { type NextRequest } from 'next/server'\n\n        import { createClient } from '@/utils/supabase/server'\n        import { redirect } from 'next/navigation'\n\n        export async function GET(request: NextRequest) {\n          const { searchParams } = new URL(request.url)\n          const token_hash = searchParams.get('token_hash')\n          const type = searchParams.get('type') as EmailOtpType | null\n          const next = searchParams.get('next') ?? '/'\n\n          if (token_hash && type) {\n            const supabase = await createClient()\n\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n            if (!error) {\n              // redirect user to specified redirect URL or root of app\n              redirect(next)\n            }\n          }\n\n          // redirect the user to an error page with some instructions\n          redirect('/auth/auth-code-error')\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"sveltekit\" label=\"SvelteKit\">\n        Create a new file at `src/routes/auth/confirm/+server.ts` and populate with the following:\n\n        ```ts src/routes/auth/confirm/+server.ts\n        import { redirect } from '@sveltejs/kit'\n        import { type EmailOtpType } from '@supabase/supabase-js'\n\n        export const GET = async (event) => {\n          const {\n            url,\n            locals: { supabase },\n          } = event\n          const token_hash = url.searchParams.get('token_hash') as string\n          const type = url.searchParams.get('type') as EmailOtpType | null\n          const next = url.searchParams.get('next') ?? '/'\n\n          /**\n           * Clean up the redirect URL by deleting the Auth flow parameters.\n           *\n           * `next` is preserved for now, because it's needed in the error case.\n           */\n          const redirectTo = new URL(url)\n          redirectTo.pathname = next\n          redirectTo.searchParams.delete('token_hash')\n          redirectTo.searchParams.delete('type')\n\n          if (token_hash && type) {\n            const { error } = await supabase.auth.verifyOtp({ token_hash, type })\n            if (!error) {\n              redirectTo.searchParams.delete('next')\n              redirect(303, redirectTo)\n            }\n          }\n\n          // return the user to an error page with some instructions\n          redirectTo.pathname = '/auth/error'\n          redirect(303, redirectTo)\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"astro\" label=\"Astro\">\n        Create a new file at `src/pages/auth/confirm.ts` and populate with the following:\n\n        ```ts src/pages/auth/confirm.ts\n        import { createServerClient, parseCookieHeader } from '@supabase/ssr'\n        import { type EmailOtpType } from '@supabase/supabase-js'\n        import { type APIRoute } from 'astro'\n\n        export const GET: APIRoute = async ({ request, cookies, redirect }) => {\n          const requestUrl = new URL(request.url)\n          const token_hash = requestUrl.searchParams.get('token_hash')\n          const type = requestUrl.searchParams.get('type') as EmailOtpType | null\n          const next = requestUrl.searchParams.get('next') || '/'\n\n          if (token_hash && type) {\n            const supabase = createServerClient(\n              import.meta.env.PUBLIC_SUPABASE_URL,\n              import.meta.env.PUBLIC_SUPABASE_PUBLISHABLE_KEY,\n              {\n                cookies: {\n                  getAll() {\n                    return parseCookieHeader(request.headers.get('Cookie') ?? '')\n                  },\n                  setAll(cookiesToSet) {\n                    cookiesToSet.forEach(({ name, value, options }) => cookies.set(name, value, options))\n                  },\n                },\n              }\n            )\n\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n\n            if (!error) {\n              return redirect(next)\n            }\n          }\n\n          // return the user to an error page with some instructions\n          return redirect('/auth/auth-code-error')\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"remix\" label=\"Remix\">\n        Create a new file at `app/routes/auth.confirm.tsx` and populate with the following:\n\n        ```ts app/routes/auth.confirm.tsx\n        import { redirect, type LoaderFunctionArgs } from '@remix-run/node'\n        import { createServerClient, parseCookieHeader, serializeCookieHeader } from '@supabase/ssr'\n        import { type EmailOtpType } from '@supabase/supabase-js'\n\n        export async function loader({ request }: LoaderFunctionArgs) {\n          const requestUrl = new URL(request.url)\n          const token_hash = requestUrl.searchParams.get('token_hash')\n          const type = requestUrl.searchParams.get('type') as EmailOtpType | null\n          const next = requestUrl.searchParams.get('next') || '/'\n          const headers = new Headers()\n\n          if (token_hash && type) {\n            const supabase = createServerClient(\n              process.env.SUPABASE_URL!,\n              process.env.SUPABASE_PUBLISHABLE_KEY!,\n              {\n                cookies: {\n                  getAll() {\n                    return parseCookieHeader(request.headers.get('Cookie') ?? '')\n                  },\n                  setAll(key, value, options) {\n                    headers.append('Set-Cookie', serializeCookieHeader(key, value, options))\n                  },\n                },\n              }\n            )\n\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n\n            if (!error) {\n              return redirect(next, { headers })\n            }\n          }\n\n          // return the user to an error page with instructions\n          return redirect('/auth/auth-code-error', { headers })\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"express\" label=\"Express\">\n        Create a new route in your express app and populate with the following:\n\n        ```js app.js\n        // The client you created from the Server-Side Auth instructions\n        const { createClient } = require(\"./lib/supabase\")\n        ...\n        app.get(\"/auth/confirm\", async function (req, res) {\n          const token_hash = req.query.token_hash\n          const type = req.query.type\n          const next = req.query.next ?? \"/\"\n\n          if (token_hash && type) {\n            const supabase = createClient({ req, res })\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n            if (!error) {\n              res.redirect(303, `/${next.slice(1)}`)\n            }\n          }\n\n          // return the user to an error page with some instructions\n          res.redirect(303, '/auth/auth-code-error')\n        })\n        ```\n      </TabPanel>\n    </Tabs>\n\n    ##### Step 3: Call the sign up function to initiate the flow\n\n    <Tabs scrollable size=\"small\" type=\"underlined\" queryGroup=\"language\">\n      <TabPanel id=\"js\" label=\"JavaScript\">\n        To sign up the user, call [signUp()](/docs/reference/javascript/auth-signup) with their email address and password:\n\n        You can optionally specify a URL to redirect to after the user clicks the confirmation link. This URL must be configured as a [Redirect URL](/docs/guides/auth/redirect-urls), which you can do in the [dashboard](/dashboard/project/_/auth/url-configuration) for hosted projects, or in the [configuration file](/docs/guides/cli/config#auth.additional_redirect_urls) for self-hosted projects.\n\n        If you don't specify a redirect URL, the user is automatically redirected to your site URL. This defaults to `localhost:3000`, but you can also configure this.\n\n        ```js\n        import { createClient } from '@supabase/supabase-js'\n        const supabase = createClient('https://your-project.supabase.co', 'sb_publishable_... or anon key')\n\n        // ---cut---\n        async function signUpNewUser() {\n          const { data, error } = await supabase.auth.signUp({\n            email: 'valid.email@supabase.io',\n            password: 'example-password',\n            options: {\n              emailRedirectTo: 'https://example.com/welcome',\n            },\n          })\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"dart\" label=\"Dart\">\n        To sign up the user, call [signUp()](/docs/reference/dart/auth-signup) with their email address and password:\n\n        ```dart\n        Future<void> signUpNewUser() async {\n          final AuthResponse res = await supabase.auth.signUp(\n            email: 'valid.email@supabase.io',\n            password: 'example-password'\n          );\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"swift\" label=\"Swift\">\n        To sign up the user, call [signUp()](/docs/reference/swift/auth-signup) with their email address and password:\n\n        ```swift\n        let response = try await supabase.auth.signUp(\n          email: \"valid.email@supabase.io\",\n          password: \"example-password\",\n        )\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"kotlin\" label=\"Kotlin\">\n        To sign up the user, call [signUpWith(Email)](/docs/reference/kotlin/auth-signup) with their email address and password:\n\n        ```kotlin\n        suspend fun signUpNewUser() {\n        \tsupabase.auth.signUpWith(Email) {\n        \t\temail = \"valid.email@supabase.io\"\n        \t\tpassword = \"example-password\"\n        \t}\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"python\" label=\"Python\">\n        To sign up the user, call [signUp()](/docs/reference/python/auth-signup) with their email address and password:\n\n        ```python\n        data = supabase.auth.sign_up({\n          'email': 'valid.email@supabase.io',\n          'password': 'example-password',\n        })\n        ```\n      </TabPanel>\n    </Tabs>\n  </TabPanel>\n</Tabs>\n\n\n### Signing in with an email and password\n\n<Tabs scrollable size=\"small\" type=\"underlined\" queryGroup=\"language\">\n  <TabPanel id=\"js\" label=\"JavaScript\">\n    When your user signs in, call [`signInWithPassword()`](/docs/reference/javascript/auth-signinwithpassword) with their email address and password:\n\n    ```js\n    import { createClient } from '@supabase/supabase-js'\n    const supabase = createClient('https://your-project.supabase.co', 'sb_publishable_... or anon key')\n\n    // ---cut---\n    async function signInWithEmail() {\n      const { data, error } = await supabase.auth.signInWithPassword({\n        email: 'valid.email@supabase.io',\n        password: 'example-password',\n      })\n    }\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"dart\" label=\"Dart\">\n    When your user signs in, call [`signInWithPassword()`](/docs/reference/dart/auth-signinwithpassword) with their email address and password:\n\n    ```dart\n    Future<void> signInWithEmail() async {\n      final AuthResponse res = await supabase.auth.signInWithPassword(\n        email: 'valid.email@supabase.io',\n        password: 'example-password'\n      );\n    }\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"swift\" label=\"Swift\">\n    When your user signs in, call [signIn(email:password:)](/docs/reference/swift/auth-signinwithpassword) with their email address and password:\n\n    ```swift\n    try await supabase.auth.signIn(\n      email: \"valid.email@supabase.io\",\n      password: \"example-password\"\n    )\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"kotlin\" label=\"Kotlin\">\n    When your user signs in, call [signInWith(Email)](/docs/reference/kotlin/auth-signinwithpassword) with their email address and password:\n\n    ```kotlin\n    suspend fun signInWithEmail() {\n    \tsupabase.auth.signInWith(Email) {\n    \t\temail = \"valid.email@supabase.io\"\n    \t\tpassword = \"example-password\"\n    \t}\n    }\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"python\" label=\"Python\">\n    When your user signs in, call [sign\\_in\\_with\\_password()](/docs/reference/python/auth-signinwithpassword) with their email address and password:\n\n    ```python\n    data = client.auth.sign_in_with_password({\n      'email': 'valid.email@supabase.io',\n      'password': 'example-password',\n    })\n    ```\n  </TabPanel>\n</Tabs>\n\n\n### Resetting a password\n\n<Tabs scrollable size=\"small\" type=\"underlined\" queryGroup=\"flow\">\n  <TabPanel id=\"implicit\" label=\"Implicit flow\">\n    #### Step 1: Create a reset password page\n\n    Create a **reset password** page. This page should be publicly accessible.\n\n    Collect the user's email address and request a password reset email. Specify the redirect URL, which should point to the URL of a **change password** page. This URL needs to be configured in your [redirect URLs](/docs/guides/auth/redirect-urls).\n\n    <Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"js\" queryGroup=\"language\">\n      <TabPanel id=\"js\" label=\"JavaScript\">\n        ```js\n        import { createClient } from '@supabase/supabase-js'\n        const supabase = createClient('https://your-project.supabase.co', 'sb_publishable_... or anon key')\n\n        // ---cut---\n        await supabase.auth.resetPasswordForEmail('valid.email@supabase.io', {\n          redirectTo: 'http://example.com/account/update-password',\n        })\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"swift\" label=\"Swift\">\n        ```swift\n        try await supabase.auth.resetPasswordForEmail(\n           \"valid.email@supabase.io\",\n           redirectTo: URL(string: \"http://example.com/account/update-password\")\n        )\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"kotlin\" label=\"Kotlin\">\n        ```kotlin\n        supabase.auth.resetPasswordForEmail(\n            email = \"valid.email@supabase.io\",\n            redirectUrl = \"http://example.com/account/update-password\"\n        )\n        ```\n\n        If you are on one of the Kotlin targets that have built-in support for redirect URL handling, such as Android, see [OAuth and OTP link verification](/docs/reference/kotlin/initializing).\n      </TabPanel>\n\n      <TabPanel id=\"python\" label=\"Python\">\n        ```python\n        client.auth.reset_password_email(\n          'valid.email@supabase.io',\n          {'redirect_to':'http://example.com/account/update-password'}\n        )\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"dart\" label=\"Dart\">\n        ```dart\n        await supabase.auth.resetPasswordForEmail(\n          'valid.email@supabase.io',\n          redirectTo: 'http://example.com/account/update-password',\n        );\n        ```\n      </TabPanel>\n    </Tabs>\n\n    #### Step 2: Create a change password page\n\n    Create a **change password** page at the URL you specified in the previous step. This page should be accessible only to authenticated users.\n\n    Collect the user's new password and call `updateUser` to update their password.\n  </TabPanel>\n\n  <TabPanel id=\"pkce\" label=\"PKCE flow\">\n    The PKCE flow allows for server-side authentication. Unlike the implicit flow, which directly provides your app with the access token after the user clicks the confirmation link, the PKCE flow requires an intermediate token exchange step before you can get the access token.\n\n    ##### Step 1: Update reset password email\n\n    Update your reset password email template to send the token hash. See [Email Templates](/docs/guides/auth/auth-email-templates) for how to configure your email templates.\n\n    Your reset password email template should contain the following HTML:\n\n    ```html\n    <h2>Reset Password</h2>\n\n    <p>Follow this link to reset the password for your user:</p>\n    <p>\n      <a\n        href=\"{{ .SiteURL }}/auth/confirm?token_hash={{ .TokenHash }}&type=recovery&next=/account/update-password\"\n        >Reset Password</a\n      >\n    </p>\n    ```\n\n    ##### Step 2: Create token exchange endpoint\n\n    Create an API endpoint at `<YOUR_SITE_URL>/auth/confirm` to handle the token exchange.\n\n    <Admonition type=\"tip\">\n      Make sure you're using the right `supabase` client in the following code.\n\n      If you're not using Server-Side Rendering or cookie-based Auth, you can directly use the `createClient` from `@supabase/supabase-js`. If you're using Server-Side Rendering, see the [Server-Side Auth guide](/docs/guides/auth/server-side/creating-a-client) for instructions on creating your Supabase client.\n    </Admonition>\n\n    <Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"nextjs\" queryGroup=\"framework\">\n      <TabPanel id=\"nextjs\" label=\"Next.js\">\n        Create a new file at `app/auth/confirm/route.ts` and populate with the following:\n\n        ```ts app/auth/confirm/route.ts\n        import { type EmailOtpType } from '@supabase/supabase-js'\n        import { cookies } from 'next/headers'\n        import { NextRequest, NextResponse } from 'next/server'\n        // The client you created from the Server-Side Auth instructions\n        import { createClient } from '@/utils/supabase/server'\n\n        export async function GET(request: NextRequest) {\n          const { searchParams } = new URL(request.url)\n          const token_hash = searchParams.get('token_hash')\n          const type = searchParams.get('type') as EmailOtpType | null\n          const next = searchParams.get('next') ?? '/'\n          const redirectTo = request.nextUrl.clone()\n          redirectTo.pathname = next\n\n          if (token_hash && type) {\n            const supabase = await createClient()\n\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n            if (!error) {\n              return NextResponse.redirect(redirectTo)\n            }\n          }\n\n          // return the user to an error page with some instructions\n          redirectTo.pathname = '/auth/auth-code-error'\n          return NextResponse.redirect(redirectTo)\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"sveltekit\" label=\"SvelteKit\">\n        Create a new file at `src/routes/auth/confirm/+server.ts` and populate with the following:\n\n        ```ts src/routes/auth/confirm/+server.ts\n        import { redirect } from '@sveltejs/kit'\n        import { type EmailOtpType } from '@supabase/supabase-js'\n\n        export const GET = async (event) => {\n          const {\n            url,\n            locals: { supabase },\n          } = event\n          const token_hash = url.searchParams.get('token_hash') as string\n          const type = url.searchParams.get('type') as EmailOtpType | null\n          const next = url.searchParams.get('next') ?? '/'\n\n          /**\n           * Clean up the redirect URL by deleting the Auth flow parameters.\n           *\n           * `next` is preserved for now, because it's needed in the error case.\n           */\n          const redirectTo = new URL(url)\n          redirectTo.pathname = next\n          redirectTo.searchParams.delete('token_hash')\n          redirectTo.searchParams.delete('type')\n\n          if (token_hash && type) {\n            const { error } = await supabase.auth.verifyOtp({ token_hash, type })\n            if (!error) {\n              redirectTo.searchParams.delete('next')\n              redirect(303, redirectTo)\n            }\n          }\n\n          // return the user to an error page with some instructions\n          redirectTo.pathname = '/auth/error'\n          redirect(303, redirectTo)\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"astro\" label=\"Astro\">\n        Create a new file at `src/pages/auth/confirm.ts` and populate with the following:\n\n        ```ts src/pages/auth/confirm.ts\n        import { createServerClient, parseCookieHeader } from '@supabase/ssr'\n        import { type EmailOtpType } from '@supabase/supabase-js'\n        import { type APIRoute } from 'astro'\n\n        export const GET: APIRoute = async ({ request, cookies, redirect }) => {\n          const requestUrl = new URL(request.url)\n          const token_hash = requestUrl.searchParams.get('token_hash')\n          const type = requestUrl.searchParams.get('type') as EmailOtpType | null\n          const next = requestUrl.searchParams.get('next') || '/'\n\n          if (token_hash && type) {\n            const supabase = createServerClient(\n              import.meta.env.PUBLIC_SUPABASE_URL,\n              import.meta.env.PUBLIC_SUPABASE_PUBLISHABLE_KEY,\n              {\n                cookies: {\n                  getAll() {\n                    return parseCookieHeader(request.headers.get('Cookie') ?? '')\n                  },\n                  setAll(cookiesToSet) {\n                    cookiesToSet.forEach(({ name, value, options }) => cookies.set(name, value, options))\n                  },\n                },\n              }\n            )\n\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n\n            if (!error) {\n              return redirect(next)\n            }\n          }\n\n          // return the user to an error page with some instructions\n          return redirect('/auth/auth-code-error')\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"remix\" label=\"Remix\">\n        Create a new file at `app/routes/auth.confirm.tsx` and populate with the following:\n\n        ```ts app/routes/auth.confirm.tsx\n        import { redirect, type LoaderFunctionArgs } from '@remix-run/node'\n        import { createServerClient, parseCookieHeader, serializeCookieHeader } from '@supabase/ssr'\n        import { type EmailOtpType } from '@supabase/supabase-js'\n\n        export async function loader({ request }: LoaderFunctionArgs) {\n          const requestUrl = new URL(request.url)\n          const token_hash = requestUrl.searchParams.get('token_hash')\n          const type = requestUrl.searchParams.get('type') as EmailOtpType | null\n          const next = requestUrl.searchParams.get('next') || '/'\n          const headers = new Headers()\n\n          if (token_hash && type) {\n            const supabase = createServerClient(\n              process.env.SUPABASE_URL!,\n              process.env.SUPABASE_PUBLISHABLE_KEY!,\n              {\n                cookies: {\n                  getAll() {\n                    return parseCookieHeader(request.headers.get('Cookie') ?? '')\n                  },\n                  setAll(key, value, options) {\n                    headers.append('Set-Cookie', serializeCookieHeader(key, value, options))\n                  },\n                },\n              }\n            )\n\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n\n            if (!error) {\n              return redirect(next, { headers })\n            }\n          }\n\n          // return the user to an error page with instructions\n          return redirect('/auth/auth-code-error', { headers })\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"express\" label=\"Express\">\n        Create a new route in your express app and populate with the following:\n\n        ```js app.js\n        // The client you created from the Server-Side Auth instructions\n        const { createClient } = require(\"./lib/supabase\")\n        ...\n        app.get(\"/auth/confirm\", async function (req, res) {\n          const token_hash = req.query.token_hash\n          const type = req.query.type\n          const next = req.query.next ?? \"/\"\n\n          if (token_hash && type) {\n            const supabase = createClient({ req, res })\n            const { error } = await supabase.auth.verifyOtp({\n              type,\n              token_hash,\n            })\n            if (!error) {\n              res.redirect(303, `/${next.slice(1)}`)\n            }\n          }\n\n          // return the user to an error page with some instructions\n          res.redirect(303, '/auth/auth-code-error')\n        })\n        ```\n      </TabPanel>\n    </Tabs>\n\n    ##### Step 3: Call the reset password by email function to initiate the flow\n\n    <Tabs scrollable size=\"small\" type=\"underlined\" queryGroup=\"language\">\n      <TabPanel id=\"js\" label=\"JavaScript\">\n        ```js\n        async function resetPassword() {\n          const { data, error } = await supabase.auth.resetPasswordForEmail(email)\n        }\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"swift\" label=\"Swift\">\n        ```swift\n        try await supabase.auth.resetPasswordForEmail(\"valid.email@supabase.io\")\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"kotlin\" label=\"Kotlin\">\n        ```kotlin\n        supabase.gotrue.sendRecoveryEmail(\n            email = \"valid.email@supabase.io\",\n        )\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"python\" label=\"Python\">\n        ```python\n        supabase.auth.reset_password_email('valid.email@supabase.io')\n        ```\n      </TabPanel>\n\n      <TabPanel id=\"dart\" label=\"Dart\">\n        ```dart\n        await supabase.auth.resetPasswordForEmail('valid.email@supabase.io');\n        ```\n      </TabPanel>\n    </Tabs>\n\n    Once you have a session, collect the user's new password and call `updateUser` to update their password.\n  </TabPanel>\n</Tabs>\n\n<Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"js\" queryGroup=\"language\">\n  <TabPanel id=\"js\" label=\"JavaScript\">\n    ```js\n    import { createClient } from '@supabase/supabase-js'\n    const supabase = createClient('url', 'anonKey')\n\n    // ---cut---\n    await supabase.auth.updateUser({ password: 'new_password' })\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"swift\" label=\"Swift\">\n    ```swift\n    try await supabase.auth.updateUser(user: UserAttributes(password: newPassword))\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"kotlin\" label=\"Kotlin\">\n    ```kotlin\n    supabase.auth.updateUser {\n        password = \"new_password\"\n    }\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"python\" label=\"Python\">\n    ```python\n    supabase.auth.update_user({'password': 'new_password'})\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"dart\" label=\"Dart\">\n    ```dart\n    final UserResponse res = await supabase.auth.updateUser(\n      UserAttributes(password: 'new_password'),\n    );\n    ```\n  </TabPanel>\n</Tabs>\n\n\n### Email sending\n\nThe signup confirmation and password reset flows require an SMTP server to send emails.\n\nThe Supabase platform comes with a default email-sending service for you to try out. The service has a rate limit of <SharedData data=\"config\">auth.rate\\_limits.email.inbuilt\\_smtp\\_per\\_hour.value</SharedData> emails per hour, and availability is on a best-effort basis. For production use, you should consider configuring a custom SMTP server.\n\n<Admonition type=\"tip\">\n  Consider configuring a custom SMTP server for production.\n</Admonition>\n\nSee the [Custom SMTP guide](/docs/guides/auth/auth-smtp) for instructions.\n\n\n#### Local development with Mailpit\n\nYou can test email flows on your local machine. The Supabase CLI automatically captures emails sent locally by using [Mailpit](https://github.com/axllent/mailpit).\n\nIn your terminal, run `supabase status` to get the Mailpit URL. Go to this URL in your browser, and follow the instructions to find your emails.\n\n\n## With phone\n\nYou can use a user's mobile phone number as an identifier, instead of an email address, when they sign up with a password.\n\nThis practice is usually discouraged because phone networks recycle mobile phone numbers. Anyone receiving a recycled phone number gets access to the original user's account. To mitigate this risk, [implement MFA](/docs/guides/auth/auth-mfa).\n\n<Admonition type=\"danger\">\n  Protect users who use a phone number as a password-based auth identifier by enabling MFA.\n</Admonition>\n\n\n### Enabling phone and password-based authentication\n\nEnable phone authentication on the [Auth Providers page](/dashboard/project/_/auth/providers) for hosted Supabase projects.\n\nFor self-hosted projects or local development, use the [configuration file](/docs/guides/cli/config#auth.sms.enable_signup). See the configuration variables namespaced under `auth.sms`.\n\nIf you want users to confirm their phone number on signup, you need to set up an SMS provider. Each provider has its own configuration. Supported providers include MessageBird, Twilio, Vonage, and TextLocal (community-supported).\n\n<AuthSmsProviderConfig />\n\n\n### Signing up with a phone number and password\n\nTo sign up the user, call [`signUp()`](/docs/reference/javascript/auth-signup) with their phone number and password:\n\n<Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"js\" queryGroup=\"language\">\n  <TabPanel id=\"js\" label=\"JavaScript\">\n    ```js\n    import { createClient } from '@supabase/supabase-js'\n    const supabase = createClient('https://your-project.supabase.co', 'sb_publishable_... or anon key')\n\n    // ---cut---\n    const { data, error } = await supabase.auth.signUp({\n      phone: '+13334445555',\n      password: 'some-password',\n    })\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"swift\" label=\"Swift\">\n    ```swift\n    try await supabase.auth.signUp(\n      phone: \"+13334445555\",\n      password: \"some-password\"\n    )\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"kotlin\" label=\"Kotlin\">\n    ```kotlin\n    supabase.auth.signUpWith(Phone) {\n        phone = \"+13334445555\"\n        password = \"some-password\"\n    }\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"python\" label=\"Python\">\n    ```python\n    supabase.auth.sign_up({\n      'phone': \"+13334445555\",\n      'password': \"some-password\"\n    })\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"dart\" label=\"Dart\">\n    ```dart\n    final AuthResponse res = await supabase.auth.signUp(\n      phone: '+13334445555',\n      password: 'some-password',\n    );\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"http\" label=\"HTTP\">\n    ```bash\n    curl -X POST 'https://cvwawazfelidkloqmbma.supabase.co/auth/v1/signup' \\\n    -H \"apikey: SUPABASE_KEY\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"phone\": \"+13334445555\",\n      \"password\": \"some-password\"\n    }'\n    ```\n  </TabPanel>\n</Tabs>\n\nIf you have phone verification turned on, the user receives an SMS with a 6-digit pin that you must verify within 60 seconds:\n\n<Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"js\" queryGroup=\"language\">\n  <TabPanel id=\"js\" label=\"JavaScript\">\n    You should present a form to the user so they can input the 6 digit pin, then send it along with the phone number to `verifyOtp`:\n\n    ```js\n    import { createClient } from '@supabase/supabase-js'\n    const supabase = createClient('https://your-project.supabase.co', 'sb_publishable_... or anon key')\n\n    // ---cut---\n    const {\n      data: { session },\n      error,\n    } = await supabase.auth.verifyOtp({\n      phone: '+13334445555',\n      token: '123456',\n      type: 'sms',\n    })\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"swift\" label=\"Swift\">\n    You should present a form to the user so they can input the 6 digit pin, then send it along with the phone number to `verifyOTP`:\n\n    ```swift\n    try await supabase.auth.verifyOTP(\n      phone: \"+13334445555\",\n      token: \"123456\",\n      type: .sms\n    )\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"kotlin\" label=\"Kotlin\">\n    You should present a form to the user so they can input the 6 digit pin, then send it along with the phone number to `verifyPhoneOtp`:\n\n    ```kotlin\n    supabase.auth.verifyPhoneOtp(\n        type = OtpType.Phone.SMS,\n        phone = \"+13334445555\",\n        token = \"123456\"\n    )\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"python\" label=\"Python\">\n    You should present a form to the user so they can input the 6 digit pin, then send it along with the phone number to `verify_otp`:\n\n    ```python\n    supabase.auth.verify_otp({\n      'phone': \"+13334445555\",\n      'token': \"123456\",\n      'type': \"sms\"\n    })\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"dart\" label=\"Dart\">\n    You should present a form to the user so they can input the 6 digit pin, then send it along with the phone number to `verifyOTP`:\n\n    ```dart\n    final AuthResponse res = await supabase.auth.verifyOTP(\n      phone: '+13334445555',\n      token: '123456',\n      type: OtpType.sms,\n    );\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"http\" label=\"HTTP\">\n    ```bash\n    curl -X POST 'https://<PROJECT_REF>.supabase.co/auth/v1/verify' \\\n    -H \"apikey: <SUPABASE_KEY>\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"type\": \"sms\",\n      \"phone\": \"+13334445555\",\n      \"token\": \"123456\"\n    }'\n    ```\n  </TabPanel>\n</Tabs>\n\n\n### Signing in a with a phone number and password\n\nCall the function to sign in with the user's phone number and password:\n\n<Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"js\" queryGroup=\"language\">\n  <TabPanel id=\"js\" label=\"JavaScript\">\n    ```js\n    import { createClient } from '@supabase/supabase-js'\n    const supabase = createClient('https://your-project.supabase.co', 'sb_publishable_... or anon key')\n\n    // ---cut---\n    const { data, error } = await supabase.auth.signInWithPassword({\n      phone: '+13334445555',\n      password: 'some-password',\n    })\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"swift\" label=\"Swift\">\n    ```swift\n    try await supabase.auth.signIn(\n      phone: \"+13334445555\",\n      password: \"some-password\"\n    )\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"kotlin\" label=\"Kotlin\">\n    ```kotlin\n    supabase.auth.signInWith(Phone) {\n        phone = \"+13334445555\"\n        password = \"some-password\"\n    }\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"python\" label=\"Python\">\n    ```python\n    supabase.auth.sign_in_with_password({\n      'phone': \"+13334445555\",\n      'password': \"some-password\"\n    })\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"dart\" label=\"Dart\">\n    ```dart\n    final AuthResponse res = await supabase.auth.signInWithPassword(\n      phone: '+13334445555',\n      password: 'some-password',\n    );\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"http\" label=\"HTTP\">\n    ```bash\n    curl -X POST 'https://cvwawazfelidkloqmbma.supabase.co/auth/v1/token?grant_type=password' \\\n    -H \"apikey: SUPABASE_KEY\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"phone\": \"+13334445555\",\n      \"password\": \"some-password\"\n    }'\n    ```\n  </TabPanel>\n</Tabs>\n"},{"title":"Migrate from Auth0 to Supabase Auth","href":"https://supabase.com/docs/guides/platform/migrating-to-supabase/auth0","content":"# Migrate from Auth0 to Supabase Auth\n\nLearn how to migrate your users from Auth0\n\nYou can migrate your users from Auth0 to Supabase Auth.\n\nChanging authentication providers for a production app is an important operation. It can affect most aspects of your application. Prepare in advance by reading this guide, and develop a plan for handling the key migration steps and possible problems.\n\nWith advance planning, a smooth and safe Auth migration is possible.\n\n\n## Before you begin\n\nBefore beginning, consider the answers to the following questions. They will help you need decide if you need to migrate, and which strategy to use:\n\n*   How do Auth provider costs scale as your user base grows?\n*   Does the new Auth provider provide all needed features? (for example, OAuth, password logins, Security Assertion Markup Language (SAML), Multi-Factor Authentication (MFA))\n*   Is downtime acceptable during the migration?\n*   What is your timeline to migrate before terminating the old Auth provider?\n\n\n## Migration strategies\n\nDepending on your evaluation, you may choose to go with one of the following strategies:\n\n1.  Rolling migration\n2.  One-off migration\n\n| Strategy | Advantages                                                                                     | Disadvantages                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| -------- | ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Rolling  | <ul><li>0 downtime</li><li>Users may need to log in again</li></ul>                            | <ul><li>Need to maintain 2 different Auth services, which may be more costly in the short-term</li><li>Need to maintain separate codepaths for the period of the migration</li><li>Some existing users may be inactive and have not signed in with the new provider. This means that you eventually need to backfill these users. However, this is a much smaller-scale one-off migration with lower risks since these users are inactive.</li></ul> |\n| One-off  | <ul><li>No need to maintain 2 different auth services for an extended period of time</li></ul> | <ul><li>Some downtime</li><li>Users will need to log in again. Risky for active users.</li></ul>                                                                                                                                                                                                                                                                                                                                                     |\n\n\n## Migration steps\n\nAuth provider migrations require 2 main steps:\n\n1.  Export your user data from the old provider (Auth0)\n2.  Import the data into your new provider (Supabase Auth)\n\n\n### Step 1: Export your user data\n\nAuth0 provides two methods for exporting user data:\n\n1.  Use the [Auth0 data export feature](https://auth0.com/docs/troubleshoot/customer-support/manage-subscriptions/export-data)\n2.  Use the [Auth0 management API](https://auth0.com/docs/api/management/v2/users/get-users). This endpoint has a rate limit, so you may need to export your users in several batches.\n\nTo export password hashes and MFA factors, contact Auth0 support.\n\n\n### Step 2: Import your users into Supabase Auth\n\nThe steps for importing your users depends on the login methods that you support.\n\nSee the following sections for how to import users with:\n\n*   [Password-based login](#password-based-methods)\n*   [Passwordless login](#passwordless-methods)\n*   [OAuth](#oauth)\n\n\n#### Password-based methods\n\nFor users who sign in with passwords, we recommend a hybrid approach to reduce downtime:\n\n1.  For new users, use Supabase Auth for sign up.\n2.  Migrate existing users in a one-off migration.\n\n\n##### Sign up new users\n\nSign up new users using Supabase Auth's [signin methods](/docs/guides/auth/passwords#signing-up-with-an-email-and-password).\n\n\n##### Migrate existing users to Supabase Auth\n\nMigrate existing users to Supabase Auth. This requires two main steps: first, check which users need to be migrated, then create their accounts using the Supabase admin endpoints.\n\n1.  Get your Auth 0 user export and password hash export lists.\n\n2.  Filter for users who use password login.\n    *   Under the `identities` field in the user object, these users will have `auth0` as a provider. In the same identity object, you can find their Auth0 `user_id`.\n    *   Check that the user has a corresponding password hash by comparing their Auth0 `user_id` to the `oid` field in the password hash export.\n\n3.  Use Supabase Auth's [admin create user](/docs/reference/javascript/auth-admin-createuser) method to recreate the user in Supabase Auth. If the user has a confirmed email address or phone number, set `email_confirm` or `phone_confirm` to `true`.\n\n    ```ts\n    import { createClient } from '@supabase/supabase-js'\n    const supabase = createClient('your_project_url', 'your_supabase_api_key')\n\n    // ---cut---\n    const { data, error } = await supabase.auth.admin.createUser({\n      email: 'valid.email@supabase.io',\n      password_hash: '$2y$10$a9pghn27d7m0ltXvlX8LiOowy7XfFw0hW0G80OjKYQ1jaoejaA7NC',\n      email_confirm: true,\n    })\n    ```\n\n    <Admonition type=\"note\" label=\"Supported password hashing algorithms\">\n      Supabase supports bcrypt and Argon2 password hashes.\n    </Admonition>\n\n    If you have a plaintext password instead of a hash, you can provide that instead. Supabase Auth will handle hashing the password for you. (Passwords are **always** stored hashed.)\n\n    ```ts\n    import { createClient } from '@supabase/supabase-js'\n    const supabase = createClient('your_project_url', 'your_supabase_api_key')\n\n    // ---cut---\n    const { data, error } = await supabase.auth.admin.createUser({\n      email: 'valid.email@supabase.io',\n      password: 'supersecurepassword123!',\n    })\n    ```\n\n4.  To sign in your migrated users, use the Supabase Auth [sign in methods](/docs/reference/javascript/auth-signinwithpassword).\n\n    To check for edge cases where users aren't successfully migrated, use a fallback strategy. This ensures that users can continue to sign in seamlessly:\n\n    1.  Try to sign in the user with Supabase Auth.\n    2.  If the signin fails, try to sign in with Auth0.\n    3.  If Auth0 signin succeeds, call the admin create user method again to create the user in Supabase Auth.\n\n\n#### Passwordless methods\n\nFor passwordless signin via email or phone, check for users with verified email addresses or phone numbers. Create these users in Supabase Auth with `email_confirm` or `phone_confirm` set to `true`:\n\n```ts\nimport { createClient } from '@supabase/supabase-js'\nconst supabase = createClient('your_project_url', 'your_supabase_api_key')\n\n// ---cut---\nconst { data, error } = await supabase.auth.admin.createUser({\n  email: 'valid.email@supabase.io',\n  email_confirm: true,\n})\n```\n\nCheck your Supabase Auth [email configuration](/docs/guides/auth/auth-smtp) and configure your [email template](/dashboard/project/_/auth/templates) for use with magic links. See the [Email templates guide](/docs/guides/auth/auth-email-templates) to learn more.\n\nOnce you have imported your users, you can sign them in using the [`signInWithOtp`](/docs/reference/javascript/auth-signinwithotp) method.\n\n\n#### OAuth\n\nConfigure your OAuth providers in Supabase by following the [Social login guides](/docs/guides/auth/social-login).\n\nFor both new and existing users, sign in the user using the [`signInWithOAuth`](/docs/reference/javascript/auth-signinwithoauth) method. This works without pre-migrating existing users, since the user always needs to sign in through the OAuth provider before being redirected to your service.\n\nAfter the user has completed the OAuth flow successfully, you can check if the user is a new or existing user in Auth0 by mapping their social provider id to Auth0. Auth0 stores the social provider ID in the user ID, which has the format `provider_name|provider_id` (for example, `github|123456`). See the [Auth0 identity docs](https://auth0.com/docs/manage-users/user-accounts/identify-users) to learn more.\n\n\n## Mapping between Auth0 and Supabase Auth\n\nEach Auth provider has its own schema for tracking users and user information.\n\nIn Supabase Auth, your users are stored in your project's database under the `auth` schema. Every user has an identity (unless the user is an anonymous user), which represents the signin method they can use with Supabase. This is represented by the `auth.users` and `auth.identities` table.\n\nSee the [Users](/docs/guides/auth/users) and [Identities](/docs/guides/auth/identities) sections to learn more.\n\n\n### Mapping user metadata and custom claims\n\nSupabase Auth provides 2 fields which you can use to map user-specific metadata from Auth0:\n\n*   `auth.users.raw_user_meta_data` : For storing non-sensitive user metadata that the user can update (e.g full name, age, favorite color).\n*   `auth.users.raw_app_meta_data` : For storing non-sensitive user metadata that the user should not be able to update (e.g pricing plan, access control roles).\n\nBoth columns are accessible from the admin user methods. To create a user with custom metadata, you can use the following method:\n\n```ts\nimport { createClient } from '@supabase/supabase-js'\nconst supabase = createClient('your_project_url', 'your_supabase_api_key')\n\n// ---cut---\nconst { data, error } = await supabase.auth.admin.createUser({\n  email: 'valid.email@supabase.io',\n  user_metadata: {\n    full_name: 'Foo Bar',\n  },\n  app_metadata: {\n    role: 'admin',\n  },\n})\n```\n\n<Admonition type=\"caution\">\n  These fields will be exposed in the user's access token JWT so it is recommended not to store excessive metadata in these fields.\n</Admonition>\n\nThese fields are stored as columns in the `auth.users` table using the `jsonb` type. Both fields can be updated by using the admin [`updateUserById` method](/docs/reference/javascript/auth-admin-updateuserbyid). If you want to allow the user to update their own `raw_user_meta_data` , you can use the [`updateUser` method](/docs/reference/javascript/auth-updateuser).\n\nIf you have a lot of user-specific metadata to store, it is recommended to create your own table in a private schema that uses the user id as a foreign key:\n\n```sql\ncreate table private.user_metadata (\n\tid int generated always as identity,\n\tuser_id uuid references auth.users(id) on delete cascade,\n\tuser_metadata jsonb\n);\n```\n\n\n## Frequently Asked Questions (FAQ)\n\n<Accordion type=\"default\" openBehaviour=\"multiple\" chevronAlign=\"right\" justified size=\"medium\" className=\"text-foreground-light mt-8 mb-6 [&>div]:space-y-4\">\n  <AccordionItem header={<span className=\"text-foreground\">I have IDs assigned to existing users in my database, how can I maintain these IDs?</span>} id=\"custom-user-id\">\n    All users stored in Supabase Auth use the UUID V4 format as the ID. If your UUID format is identical, you can specify it in the admin create user method like this:\n\n    <Admonition type=\"note\">\n      New users in Supabase Auth will always be created with a UUID V4 ID by default.\n    </Admonition>\n\n    ```ts\n    // specify a custom id\n    const { data, error } = await supabase.auth.admin.createUser({\n      id: 'e7f5ae65-376e-4d05-a18c-10a91295727a',\n      email: 'valid.email@supabase.io',\n    })\n    ```\n  </AccordionItem>\n\n  <AccordionItem header={<span className=\"text-foreground\">How can I allow my users to retain their existing password?</span>} id=\"existing-password\">\n    Supabase Auth never stores passwords as plaintext. Since Supabase Auth supports reading bcrypt and argon2 password hashes, you can import your users passwords if they use the same hashing algorithm. New users in Supabase Auth who use password-based sign-in methods will always use a bcrypt hash. Passwords are stored in the `auth.users.encrypted_password` column.\n  </AccordionItem>\n\n  <AccordionItem header={<span className=\"text-foreground\">My users have multi-factor authentication (MFA) enabled, how do I make sure they don't have to set up MFA again?</span>} id=\"mfa\">\n    You can obtain an export of your users' MFA secrets by opening a support ticket with Auth0, similar to obtaining the export for password hashes. Supabase Auth only supports time-based one-time passwords (TOTP). Users who have TOTP-based factors may need to re-enroll using their choice of TOTP-based authenticator instead (e.g. 1Password / Google authenticator).\n  </AccordionItem>\n\n  <AccordionItem header={<span className=\"text-foreground\">How do I migrate existing SAML Single Sign-On (SSO) connections?</span>} id=\"saml\">\n    Customers may need to link their identity provider with Supabase Auth separately, but their users should still be able to sign-in as per-normal after authenticating with their identity provider. For more information about SSO with SAML 2.0, you can check out [this guide](/docs/guides/auth/enterprise-sso/auth-sso-saml). If you want to migrate your existing SAML SSO connections from Auth0 to Supabase Auth, reach out to us via support.\n  </AccordionItem>\n\n  <AccordionItem header={<span className=\"text-foreground\">How do I migrate my Auth0 organizations to Supabase?</span>} id=\"migrate-org\">\n    This isn't supported by Supabase Auth yet.\n  </AccordionItem>\n</Accordion>\n\n\n## Useful references\n\n*   [Migrating 125k users from Auth0 to Supabase](https://kevcodez.medium.com/migrating-125-000-users-from-auth0-to-supabase-81c0568de307)\n*   [Loper to Supabase migration](https://eigen.sh/posts/auth-migration)\n"},{"title":"OAuth 2.1 Flows","href":"https://supabase.com/docs/guides/auth/oauth-server/oauth-flows","content":"# OAuth 2.1 Flows\n\n\n\nSupabase Auth implements OAuth 2.1 with OpenID Connect (OIDC), supporting the authorization code flow with PKCE and refresh token flow. This guide explains how these flows work in detail.\n\n<Admonition type=\"note\">\n  This guide explains the OAuth 2.1 flows for **third-party client applications** that authenticate with your Supabase project. These flows require custom implementation and are not available in the `@supabase/supabase-js` library. The `supabase-js` library is for authenticating **with** Supabase Auth as an identity provider, not for building your own OAuth server.\n</Admonition>\n\n\n## Supported grant types\n\nSupabase Auth supports two OAuth 2.1 grant types:\n\n1.  **Authorization Code with PKCE** (`authorization_code`) - For obtaining initial access tokens\n2.  **Refresh Token** (`refresh_token`) - For obtaining new access tokens without re-authentication\n\n<Admonition type=\"note\">\n  Other grant types like `client_credentials` or `password` are not supported.\n</Admonition>\n\n\n## Authorization code flow with PKCE\n\nThe authorization code flow with PKCE (Proof Key for Code Exchange) is the recommended flow for all OAuth clients, including single-page applications, mobile apps, and server-side applications.\n\n\n### How it works\n\nThe flow consists of several steps:\n\n1.  **Client initiates authorization** - Third-party app redirects user to Supabase Auth's authorize endpoint\n2.  **Supabase validates and redirects** - Supabase Auth validates OAuth parameters and redirects user to your configured authorization URL\n3.  **User authenticates and authorizes** - Your frontend checks if user is logged in, shows consent screen, and handles approval/denial\n4.  **Authorization code issued** - Supabase Auth generates a short-lived authorization code and redirects back to client\n5.  **Code exchange** - Client exchanges the code for tokens\n6.  **Access granted** - Client receives access token, refresh token, and ID token\n\n\n### Flow diagram\n\nHere's a visual representation of the complete authorization code flow:\n\n```\n                            \n                                                                             \n   Client                     Your Auth UI                   Supabase Auth   \n     App                      (Frontend)                                     \n                                                                             \n                            \n                                                                      \n         1. Generate PKCE params                                       \n            (code_verifier, code_challenge)                            \n                                                                      \n         2. Redirect to /oauth/authorize with code_challenge           \n       >\n                                                                      \n                                       3. Validate params & redirect  \n                                          to authorization_path       \n                                     <\n                                                                      \n                                       4. getAuthorizationDetails()   \n                                     >\n                                       Return client info             \n                                     <\n                                                                      \n                                       5. User login & consent        \n                                                                      \n                                       6. approveAuthorization()      \n                                     >\n                                       Return redirect_to with code   \n                                     <\n                                                                      \n         7. Redirect to client callback with code                      \n       <\n                                                                      \n         8. Exchange code for tokens (POST /oauth/token)               \n            with code_verifier                                         \n       >\n                                                                      \n         9. Return tokens (access, refresh, ID)                        \n       <\n                                                                      \n         10. Access resources with access_token                        \n                                                                      \n         11. Refresh tokens (POST /oauth/token with refresh_token)     \n       >\n                                                                      \n         12. Return new tokens                                         \n       <\n                                                                      \n```\n\n**Key points:**\n\n*   Third-party client redirects user to **Supabase Auth's authorize endpoint** (not directly to your UI)\n*   Supabase Auth validates OAuth parameters and redirects to **your authorization path**\n*   Your frontend UI handles authentication and consent using `supabase-js` OAuth methods\n*   Supabase Auth handles all backend OAuth logic (code generation, token issuance)\n\n\n### Step 1: Generate PKCE parameters\n\nBefore initiating the flow, the client must generate PKCE parameters:\n\n```javascript\n// Generate a random code verifier (43-128 characters)\nfunction generateCodeVerifier() {\n  const array = new Uint8Array(32)\n  crypto.getRandomValues(array)\n  return base64URLEncode(array)\n}\n\n// Create code challenge from verifier\nasync function generateCodeChallenge(verifier) {\n  const encoder = new TextEncoder()\n  const data = encoder.encode(verifier)\n  const hash = await crypto.subtle.digest('SHA-256', data)\n  return base64URLEncode(new Uint8Array(hash))\n}\n\nfunction base64URLEncode(buffer) {\n  return btoa(String.fromCharCode(...buffer))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '')\n}\n\n// Generate and store verifier (you'll need it later)\nconst codeVerifier = generateCodeVerifier()\nsessionStorage.setItem('code_verifier', codeVerifier)\n\n// Generate challenge to send in authorization request\nconst codeChallenge = await generateCodeChallenge(codeVerifier)\n```\n\n\n### Step 2: Authorization request\n\nThe client redirects the user to your authorization endpoint with the following parameters:\n\n```\nhttps://<project-ref>.supabase.co/auth/v1/oauth/authorize?\n  response_type=code\n  &client_id=<client-id>\n  &redirect_uri=<configured-redirect-uri>\n  &state=<random-state>\n  &code_challenge=<code-challenge>\n  &code_challenge_method=S256\n```\n\n\n#### Required parameters\n\n| Parameter               | Description                                  |\n| ----------------------- | -------------------------------------------- |\n| `response_type`         | Must be `code` for authorization code flow   |\n| `client_id`             | The client ID from registration              |\n| `redirect_uri`          | Must exactly match a registered redirect URI |\n| `code_challenge`        | The generated code challenge                 |\n| `code_challenge_method` | Must be `S256` (SHA-256)                     |\n\n\n#### Optional parameters\n\n| Parameter | Description                                                                                                                                                                                                                                                                                                                  |\n| --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `state`   | Random string to prevent CSRF attacks (highly recommended)                                                                                                                                                                                                                                                                   |\n| `scope`   | Space-separated list of scopes (e.g., `openid email profile phone`). Requested scopes will be included in the access token and control what information is returned by the UserInfo endpoint. Default scope when none provided is `email`. If the `openid` scope is requested, an ID token will be included in the response. |\n| `nonce`   | Random string for replay attack protection. If provided, will be included in the ID token.                                                                                                                                                                                                                                   |\n\n<Admonition type=\"caution\">\n  Always include a `state` parameter to protect against CSRF attacks. Generate a random string, store it in session storage, and verify it matches when the user returns.\n</Admonition>\n\n\n### Step 3: User authentication and consent\n\nAfter receiving the authorization request, Supabase Auth validates the OAuth parameters (client\\_id, redirect\\_uri, PKCE, etc.) and then redirects the user to your configured **authorization path** (e.g., `https://example.com/oauth/consent?authorization_id=<id>`).\n\nThe URL will contain an `authorization_id` query parameter that identifies this authorization request.\n\nYour frontend application at the authorization path should:\n\n1.  **Extract authorization\\_id** - Get the `authorization_id` from the URL query parameters\n2.  **Fetch authorization details** - Call `supabase.auth.oauth.getAuthorizationDetails(authorization_id)` to retrieve information about the OAuth client and request parameters\n3.  **Check user authentication** - Verify if the user is logged in; if not, redirect to your login page (preserving the full authorization path including the `authorization_id`). After successful login, redirect the user back to the authorization path with the same `authorization_id` query parameter\n4.  **Display consent screen** - Show the user information about the requesting client (name, redirect URI, scopes)\n5.  **Handle user decision** - When the user approves or denies:\n    *   Call `supabase.auth.oauth.approveAuthorization(authorization_id)` to approve\n    *   Call `supabase.auth.oauth.denyAuthorization(authorization_id)` to deny\n    *   Redirect user to the returned `redirect_to` URL\n\nThis is a **frontend implementation** using `supabase-js`. Supabase Auth handles all the backend OAuth logic (generating authorization codes, validating requests, etc.) after you call the approve/deny methods.\n\nSee the [Getting Started guide](/docs/guides/auth/oauth-server/getting-started#example-authorization-ui) for complete implementation examples.\n\n\n### Step 4: Authorization code issued\n\nIf the user approves access, Supabase Auth redirects back to the client's redirect URI with an authorization code:\n\n```\nhttps://client-app.com/callback?\n  code=<authorization-code>\n  &state=<state-from-request>\n```\n\nThe authorization code is:\n\n*   **Short-lived** - Valid for 10 minutes\n*   **Single-use** - Can only be exchanged once\n*   **Bound to PKCE** - Can only be exchanged with the correct code verifier\n\nIf the user denies access, Supabase Auth redirects with error information in query parameters:\n\n```\nhttps://client-app.com/callback?\n  error=access_denied\n  &error_description=The+user+denied+the+authorization+request\n  &state=<state-from-request>\n```\n\nThe error parameters allow clients to display relevant error messages to users:\n\n| Parameter           | Description                                                           |\n| ------------------- | --------------------------------------------------------------------- |\n| `error`             | Error code (e.g., `access_denied`, `invalid_request`, `server_error`) |\n| `error_description` | Human-readable error description explaining what went wrong           |\n| `state`             | The state parameter from the original request (for CSRF protection)   |\n\n\n### Step 5: Token exchange\n\nThe client exchanges the authorization code for tokens by making a POST request to the token endpoint:\n\n```bash\ncurl -X POST 'https://<project-ref>.supabase.co/auth/v1/oauth/token' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -d 'grant_type=authorization_code' \\\n  -d 'code=<authorization-code>' \\\n  -d 'client_id=<client-id>' \\\n  -d 'redirect_uri=<redirect-uri>' \\\n  -d 'code_verifier=<code-verifier>'\n```\n\nFor confidential clients (with client secret):\n\n```bash\ncurl -X POST 'https://<project-ref>.supabase.co/auth/v1/oauth/token' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -d 'grant_type=authorization_code' \\\n  -d 'code=<authorization-code>' \\\n  -d 'client_id=<client-id>' \\\n  -d 'client_secret=<client-secret>' \\\n  -d 'redirect_uri=<redirect-uri>' \\\n  -d 'code_verifier=<code-verifier>'\n```\n\n\n#### Example in JavaScript\n\n```javascript\n// Retrieve the code verifier from storage\nconst codeVerifier = sessionStorage.getItem('code_verifier')\n\n// Exchange code for tokens\nconst response = await fetch(`https://<project-ref>.supabase.co/auth/v1/oauth/token`, {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n  },\n  body: new URLSearchParams({\n    grant_type: 'authorization_code',\n    code: authorizationCode,\n    client_id: '<client-id>',\n    redirect_uri: '<redirect-uri>',\n    code_verifier: codeVerifier,\n  }),\n})\n\nconst tokens = await response.json()\n```\n\n\n### Step 6: Token response\n\nOn success, Supabase Auth returns a JSON response with tokens:\n\n```json\n{\n  \"access_token\": \"eyJhbGc...\",\n  \"token_type\": \"bearer\",\n  \"expires_in\": 3600,\n  \"refresh_token\": \"MXff...\",\n  \"scope\": \"openid email profile\",\n  \"id_token\": \"eyJhbGc...\"\n}\n```\n\n| Field           | Description                                                                                          |\n| --------------- | ---------------------------------------------------------------------------------------------------- |\n| `access_token`  | JWT access token for accessing resources                                                             |\n| `token_type`    | Always `bearer`                                                                                      |\n| `expires_in`    | Token lifetime in seconds (default: 3600)                                                            |\n| `refresh_token` | Token for obtaining new access tokens                                                                |\n| `scope`         | Granted scopes from the authorization request                                                        |\n| `id_token`      | OpenID Connect ID token (included only if `openid` scope was requested in the authorization request) |\n\n\n## Access token structure\n\nAccess tokens are JWTs containing standard Supabase claims plus OAuth-specific claims:\n\n```json\n{\n  \"aud\": \"authenticated\",\n  \"exp\": 1735819200,\n  \"iat\": 1735815600,\n  \"iss\": \"https://<project-ref>.supabase.co/auth/v1\",\n  \"sub\": \"user-uuid\",\n  \"email\": \"user@example.com\",\n  \"phone\": \"\",\n  \"app_metadata\": {\n    \"provider\": \"email\",\n    \"providers\": [\"email\"]\n  },\n  \"user_metadata\": {},\n  \"role\": \"authenticated\",\n  \"aal\": \"aal1\",\n  \"amr\": [\n    {\n      \"method\": \"password\",\n      \"timestamp\": 1735815600\n    }\n  ],\n  \"session_id\": \"session-uuid\",\n  \"client_id\": \"9a8b7c6d-5e4f-3a2b-1c0d-9e8f7a6b5c4d\"\n}\n```\n\n\n### OAuth-specific claims\n\n| Claim       | Description                                  |\n| ----------- | -------------------------------------------- |\n| `client_id` | The OAuth client ID that obtained this token |\n\nAll other claims follow the standard [Supabase JWT structure](/docs/guides/auth/jwts).\n\n\n### Available scopes\n\nThe following scopes are currently supported:\n\n| Scope     | Description                                                                           |\n| --------- | ------------------------------------------------------------------------------------- |\n| `openid`  | Enables OpenID Connect. When requested, an ID token will be included in the response. |\n| `email`   | Grants access to email and email\\_verified claims                                     |\n| `profile` | Grants access to profile information (name, picture, etc.)                            |\n| `phone`   | Grants access to phone\\_number and phone\\_number\\_verified claims                     |\n\n**Default scope:** When no scope is specified in the authorization request, the default scope is `email`.\n\nScopes affect what information is included in ID tokens and returned by the UserInfo endpoint. All OAuth access tokens have full access to user data (same as regular session tokens), with the addition of the `client_id` claim. Use Row Level Security policies with the `client_id` claim to control which data each OAuth client can access.\n\n<Admonition type=\"note\">\n  **Custom scopes are not currently supported.** Only the standard scopes listed above are available. Support for custom scopes is planned for a future release, which will allow you to define application-specific permissions and fine-grained access control.\n</Admonition>\n\n\n## Refresh token flow\n\nRefresh tokens allow clients to obtain new access tokens without requiring the user to re-authenticate.\n\n\n### When to refresh\n\nClients should refresh access tokens when:\n\n*   The access token is expired (check the `exp` claim)\n*   The access token is about to expire (proactive refresh)\n*   An API call returns a 401 Unauthorized error\n\n\n### Refresh request\n\nMake a POST request to the token endpoint with the refresh token:\n\n```bash\ncurl -X POST 'https://<project-ref>.supabase.co/auth/v1/oauth/token' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -d 'grant_type=refresh_token' \\\n  -d 'refresh_token=<refresh-token>' \\\n  -d 'client_id=<client-id>'\n```\n\nFor confidential clients:\n\n```bash\ncurl -X POST 'https://<project-ref>.supabase.co/auth/v1/oauth/token' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -d 'grant_type=refresh_token' \\\n  -d 'refresh_token=<refresh-token>' \\\n  -d 'client_id=<client-id>' \\\n  -d 'client_secret=<client-secret>'\n```\n\n\n#### Example in JavaScript\n\n```javascript\nasync function refreshAccessToken(refreshToken) {\n  const response = await fetch(`https://<project-ref>.supabase.co/auth/v1/oauth/token`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      grant_type: 'refresh_token',\n      refresh_token: refreshToken,\n      client_id: '<client-id>',\n    }),\n  })\n\n  if (!response.ok) {\n    throw new Error('Failed to refresh token')\n  }\n\n  return await response.json()\n}\n```\n\n\n### Refresh response\n\nThe response contains a new access token and optionally a new refresh token:\n\n```json\n{\n  \"access_token\": \"eyJhbGc...\",\n  \"token_type\": \"bearer\",\n  \"expires_in\": 3600,\n  \"refresh_token\": \"v1.MXff...\",\n  \"scope\": \"openid email profile\"\n}\n```\n\n<Admonition type=\"note\">\n  Refresh tokens may be rotated (a new refresh token is issued). Always update your stored refresh token when a new one is provided.\n</Admonition>\n\n\n## OpenID Connect (OIDC)\n\nSupabase Auth supports OpenID Connect, an identity layer on top of OAuth 2.1.\n\n<Admonition type=\"note\">\n  **ID tokens are only included when the `openid` scope is requested.** To receive an ID token, include `openid` in the space-separated list of scopes in your authorization request. ID tokens are valid for 1 hour.\n</Admonition>\n\n\n### ID tokens\n\nID tokens are JWTs that contain user identity information. They are signed by Supabase Auth and can be verified by clients.\n\nThe claims included in the ID token depend on the scopes requested during authorization. For example, requesting `openid email profile` will include email and profile-related claims, while requesting only `openid email` will include only email-related claims.\n\n\n#### Example ID token\n\n```json\n{\n  \"iss\": \"https://<project-ref>.supabase.co/auth/v1\",\n  \"sub\": \"user-uuid\",\n  \"aud\": \"client-id\",\n  \"exp\": 1735819200,\n  \"iat\": 1735815600,\n  \"auth_time\": 1735815600,\n  \"nonce\": \"random-nonce-from-request\",\n  \"email\": \"user@example.com\",\n  \"email_verified\": true,\n  \"phone_number\": \"+1234567890\",\n  \"phone_number_verified\": false,\n  \"name\": \"John Doe\",\n  \"picture\": \"https://example.com/avatar.jpg\"\n}\n```\n\n\n#### Standard OIDC claims\n\n| Claim                   | Description                                                  |\n| ----------------------- | ------------------------------------------------------------ |\n| `sub`                   | Subject (user ID)                                            |\n| `nonce`                 | The nonce value from the authorization request (if provided) |\n| `email`                 | User's email address                                         |\n| `email_verified`        | Whether the email is verified                                |\n| `phone_number`          | User's phone number                                          |\n| `phone_number_verified` | Whether the phone is verified                                |\n| `name`                  | User's full name                                             |\n| `picture`               | User's profile picture URL                                   |\n\n\n### UserInfo endpoint\n\nClients can retrieve user information by calling the UserInfo endpoint with an access token:\n\n```bash\ncurl 'https://<project-ref>.supabase.co/auth/v1/oauth/userinfo' \\\n  -H 'Authorization: Bearer <access-token>'\n```\n\nThe information returned depends on the scopes granted in the access token. For example:\n\n**With `email` scope:**\n\n```json\n{\n  \"sub\": \"user-uuid\",\n  \"email\": \"user@example.com\",\n  \"email_verified\": true\n}\n```\n\n**With `email profile phone` scopes:**\n\n```json\n{\n  \"sub\": \"user-uuid\",\n  \"email\": \"user@example.com\",\n  \"email_verified\": true,\n  \"phone_number\": \"+1234567890\",\n  \"phone_number_verified\": false,\n  \"name\": \"John Doe\",\n  \"picture\": \"https://example.com/avatar.jpg\"\n}\n```\n\n\n### OIDC discovery\n\nSupabase Auth exposes OpenID Connect and OAuth 2.1 discovery endpoints that describe its capabilities:\n\n```\nhttps://<project-ref>.supabase.co/auth/v1/.well-known/openid-configuration\nhttps://<project-ref>.supabase.co/auth/v1/.well-known/oauth-authorization-server\n```\n\n<Admonition type=\"note\">\n  Both endpoints return the same metadata and can be used interchangeably. They are provided for compatibility with different OAuth and OIDC clients that may expect one or the other.\n</Admonition>\n\nThese endpoints return metadata about:\n\n*   Available endpoints (authorization, token, userinfo, JWKS)\n*   Supported grant types and response types\n*   Supported scopes and claims\n*   Token signing algorithms\n\nThis enables automatic integration with OIDC-compliant libraries and tools.\n\n\n## Token validation\n\nThird-party clients should validate access tokens to ensure they're authentic and not tampered with.\n\n<Admonition type=\"tip\">\n  **Recommended: Use asymmetric JWT signing keys**\n\n  For OAuth implementations, we strongly recommend using asymmetric signing algorithms (RS256 or ES256) instead of the default HS256. With asymmetric keys, third-party clients can validate JWTs using the public key from your JWKS endpoint without needing access to your JWT secret. This is more secure, scalable, and follows OAuth best practices.\n\n  Learn how to [configure asymmetric JWT signing keys](/docs/guides/auth/signing-keys) in your project.\n</Admonition>\n\n<Admonition type=\"caution\">\n  **ID tokens require asymmetric signing algorithms**\n\n  If you request the `openid` scope to receive ID tokens, your project must be configured to use asymmetric signing algorithms (RS256 or ES256). ID token generation will fail with an error if your project is still using the default HS256 symmetric algorithm. This is a security requirement of the OpenID Connect specification.\n</Admonition>\n\n\n### JWKS endpoint\n\nSupabase Auth exposes a JSON Web Key Set (JWKS) endpoint containing public keys for token verification:\n\n```\nhttps://<project-ref>.supabase.co/auth/v1/.well-known/jwks.json\n```\n\nExample response:\n\n```json\n{\n  \"keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"kid\": \"key-id\",\n      \"use\": \"sig\",\n      \"alg\": \"RS256\",\n      \"n\": \"...\",\n      \"e\": \"AQAB\"\n    }\n  ]\n}\n```\n\n\n### Validating tokens\n\nUse a JWT library to verify tokens:\n\n<Tabs scrollable size=\"small\" type=\"underlined\" defaultActiveId=\"node\" queryGroup=\"language\">\n  <TabPanel id=\"node\" label=\"Node.js\">\n    ```javascript\n    import { createRemoteJWKSet, jwtVerify } from 'jose'\n\n    const JWKS = createRemoteJWKSet(\n      new URL('https://<project-ref>.supabase.co/auth/v1/.well-known/jwks.json')\n    )\n\n    async function verifyAccessToken(token) {\n      try {\n        const { payload } = await jwtVerify(token, JWKS, {\n          issuer: 'https://<project-ref>.supabase.co/auth/v1',\n          audience: 'authenticated',\n        })\n        return payload\n      } catch (error) {\n        console.error('Token verification failed:', error)\n        return null\n      }\n    }\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"python\" label=\"Python\">\n    ```python\n    from jose import jwt\n    from jose.backends import RSAKey\n    import requests\n\n    # Fetch JWKS\n    jwks = requests.get('https://<project-ref>.supabase.co/auth/v1/.well-known/jwks.json').json()\n\n    def verify_access_token(token):\n        try:\n            payload = jwt.decode(\n                token,\n                jwks,\n                algorithms=['RS256'],\n                issuer='https://<project-ref>.supabase.co/auth/v1',\n                audience='authenticated'\n            )\n            return payload\n        except jwt.JWTError as e:\n            print(f'Token verification failed: {e}')\n            return None\n    ```\n  </TabPanel>\n\n  <TabPanel id=\"go\" label=\"Go\">\n    ```go\n    package main\n\n    import (\n        \"context\"\n        \"github.com/coreos/go-oidc/v3/oidc\"\n    )\n\n    func verifyAccessToken(ctx context.Context, token string) (*oidc.IDToken, error) {\n        provider, err := oidc.NewProvider(\n            ctx,\n            \"https://<project-ref>.supabase.co/auth/v1\",\n        )\n        if err != nil {\n            return nil, err\n        }\n\n        verifier := provider.Verifier(&oidc.Config{\n            ClientID: \"authenticated\",\n        })\n\n        return verifier.Verify(ctx, token)\n    }\n    ```\n  </TabPanel>\n</Tabs>\n\n\n### What to validate\n\nAlways verify:\n\n1.  **Signature** - Token is signed by Supabase Auth\n2.  **Issuer** (`iss`) - Matches your project URL\n3.  **Audience** (`aud`) - Is `authenticated`\n4.  **Expiration** (`exp`) - Token is not expired\n5.  **Client ID** (`client_id`) - Matches your client (if applicable)\n\n\n## Managing user grants\n\nUsers can view and manage the OAuth applications they've authorized to access their account. This is important for transparency and security, allowing users to audit and revoke access when needed.\n\n\n### Viewing authorized applications\n\nUsers can retrieve a list of all OAuth clients they've authorized:\n\n```javascript\nconst { data: grants, error } = await supabase.auth.oauth.getUserGrants()\n\nif (error) {\n  console.error('Error fetching grants:', error)\n} else {\n  console.log('Authorized applications:', grants)\n}\n```\n\nThe response includes details about each authorized OAuth client:\n\n```json\n[\n  {\n    \"id\": \"grant-uuid\",\n    \"client_id\": \"9a8b7c6d-5e4f-3a2b-1c0d-9e8f7a6b5c4d\",\n    \"client_name\": \"My Third-Party App\",\n    \"scopes\": [\"email\", \"profile\"],\n    \"created_at\": \"2025-01-15T10:30:00.000Z\",\n    \"updated_at\": \"2025-01-15T10:30:00.000Z\"\n  }\n]\n```\n\n\n### Revoking access\n\nUsers can revoke access for a specific OAuth client at any time. When access is revoked, all active sessions and refresh tokens for that client are immediately invalidated:\n\n```javascript\nconst { error } = await supabase.auth.oauth.revokeGrant(clientId)\n\nif (error) {\n  console.error('Error revoking access:', error)\n} else {\n  console.log('Access revoked successfully')\n}\n```\n\nAfter revoking access:\n\n*   All refresh tokens for that client are deleted\n*   The user will need to re-authorize the application to grant access again\n\n<Admonition type=\"tip\">\n  **Build a settings page for your users**\n\n  It's a good practice to provide a settings page where users can view all authorized applications and revoke access to any they no longer trust or use. This increases transparency and gives users control over their data.\n</Admonition>\n\nFor complete API reference, see the [OAuth methods in supabase-js](/docs/reference/javascript/auth-oauth).\n\n\n## Next steps\n\n*   [Implement MCP authentication](/docs/guides/auth/oauth-server/mcp-authentication) - Enable AI agent authentication\n*   [Secure with RLS](/docs/guides/auth/oauth-server/token-security) - Control data access for OAuth clients\n*   [Learn about JWTs](/docs/guides/auth/jwts) - Understand Supabase token structure\n"}]}}

</mcp_external_output>